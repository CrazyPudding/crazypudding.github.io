<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <meta name="msapplication-config" content="/images/browserconfig.xml">
  <meta name="google-site-verification" content="v4WrTLM4pCJ7GqyDZCubQai7qb5ypHbCQYSA7cabnJA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Dancing Script:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.crazypudding.com","root":"/","scheme":"Gemini","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="关于异步，大家并不陌生，每种语言都有自己的实现。关于 Dart 的异步，大家也许听到过 Dart 是单线程语言，但是为什么单线程能实现异步？单线程如何利用 CPU 多核的能力？之前没有过类似经验的同学可能会有很多问号。也许本文能解释其中一部分问题，让刚接触 Dart 的同学有一个整体的概念，对于后续 Dart 的异步编程会有不少帮助。 本文主要包括两部分，第一部分是关于 Future、Stream">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析 Dart 异步机制">
<meta property="og:url" content="https://www.crazypudding.com/2020/09/02/dart-async-mechanism/">
<meta property="og:site_name" content="CrazyPudding&#39;s Note">
<meta property="og:description" content="关于异步，大家并不陌生，每种语言都有自己的实现。关于 Dart 的异步，大家也许听到过 Dart 是单线程语言，但是为什么单线程能实现异步？单线程如何利用 CPU 多核的能力？之前没有过类似经验的同学可能会有很多问号。也许本文能解释其中一部分问题，让刚接触 Dart 的同学有一个整体的概念，对于后续 Dart 的异步编程会有不少帮助。 本文主要包括两部分，第一部分是关于 Future、Stream">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.crazypudding.com/dart-async-mechanism/event-loop.png">
<meta property="og:image" content="http://img.crazypudding.com/dart-async-mechanism/dart-event-queues-order.png">
<meta property="og:image" content="http://img.crazypudding.com/dart-async-mechanism/isolate-communicate.png">
<meta property="article:published_time" content="2020-09-02T07:00:00.000Z">
<meta property="article:modified_time" content="2020-09-06T04:20:47.319Z">
<meta property="article:author" content="Crazypudding">
<meta property="article:tag" content="Learning Notes">
<meta property="article:tag" content="Flutter">
<meta property="article:tag" content="Dart">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.crazypudding.com/dart-async-mechanism/event-loop.png">

<link rel="canonical" href="https://www.crazypudding.com/2020/09/02/dart-async-mechanism/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>浅析 Dart 异步机制 | CrazyPudding's Note</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-172930850-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-172930850-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3c0226d1e15c67d14d87c4d6771bfb82";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">CrazyPudding's Note</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#异步-API"><span class="nav-number">1.</span> <span class="nav-text">异步 API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Future"><span class="nav-number">1.1.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future-是什么"><span class="nav-number">1.2.</span> <span class="nav-text">Future 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future-的使用"><span class="nav-number">1.3.</span> <span class="nav-text">Future 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream"><span class="nav-number">1.4.</span> <span class="nav-text">Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-的创建"><span class="nav-number">1.5.</span> <span class="nav-text">Stream 的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream-的种类"><span class="nav-number">1.6.</span> <span class="nav-text">Stream 的种类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步机制"><span class="nav-number">2.</span> <span class="nav-text">异步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异步概览"><span class="nav-number">2.1.</span> <span class="nav-text">异步概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Isolate-的使用"><span class="nav-number">2.2.</span> <span class="nav-text">Isolate 的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thanks-To"><span class="nav-number">4.</span> <span class="nav-text">Thanks To</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Crazypudding"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Crazypudding</p>
  <div class="site-description" itemprop="description">有道无术术尚可求，有术无道止于术</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/crazypudding" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;crazypudding" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/crazypudding" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.crazypudding.com/2020/09/02/dart-async-mechanism/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Crazypudding">
      <meta itemprop="description" content="有道无术术尚可求，有术无道止于术">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyPudding's Note">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          浅析 Dart 异步机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-02 15:00:00" itemprop="dateCreated datePublished" datetime="2020-09-02T15:00:00+08:00">2020-09-02</time>
            </span>

          
            <span id="/2020/09/02/dart-async-mechanism/" class="post-meta-item leancloud_visitors" data-flag-title="浅析 Dart 异步机制" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/09/02/dart-async-mechanism/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/02/dart-async-mechanism/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>关于异步，大家并不陌生，每种语言都有自己的实现。关于 Dart 的异步，大家也许听到过 Dart 是单线程语言，但是为什么单线程能实现异步？单线程如何利用 CPU 多核的能力？之前没有过类似经验的同学可能会有很多问号。也许本文能解释其中一部分问题，让刚接触 Dart 的同学有一个整体的概念，对于后续 Dart 的异步编程会有不少帮助。</p>
<p>本文主要包括两部分，第一部分是关于 <code>Future</code>、<code>Stream</code> 这类异步 API 的简单介绍，对 Dart 异步代码有一个初步印象；第二部分是关于 Dart 异步机制的整体介绍，从全局的层面了解 Dart 的异步实现，先有了大的概念，不管是后续的 Coding 还是更细致的原理研究，都会有一定的帮助。</p>
<a id="more"></a>

<h2 id="异步-API"><a href="#异步-API" class="headerlink" title="异步 API"></a>异步 API</h2><p>说到异步，对于 Android 端的同学来讲，最熟悉的莫过于网络请求了。因此，作为 Android 出身的我，就从一个网络请求说起，开始这一次 Dart 异步之旅。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpClient()                                                            <span class="comment">// 创建 HttpClient</span></span><br><span class="line">  .getUrl(<span class="built_in">Uri</span>.parse(<span class="string">'&lt;https://jsonplaceholder.typicode.com/posts/1’&gt;))  // 返回 Future&lt;HttpClientRequest&gt;</span></span><br><span class="line"><span class="string">  .then((HttpClientRequest request) =&gt; request.close())                 // 返回 Future&lt;HttpClientResponse&gt;</span></span><br><span class="line"><span class="string">  .then((HttpClientResponse response) =&gt;                                </span></span><br><span class="line"><span class="string">    response.transform(utf8.decoder).listen(print))                     // 返回 Future&lt;void&gt;</span></span><br><span class="line"><span class="string">  .catchError((e) =&gt; print(e))</span></span><br><span class="line"><span class="string">  .whenComplete(() =&gt; print(‘Complete'</span>));</span><br></pre></td></tr></table></figure>

<p>以上就是利用 Dart SDK 中的 API 实现的网络请求，看不懂没关系，现在只要知道 <code>HttpClientRequest</code> 可以用来设置网络请求的配置比如请求头之类的，而 <code>HttpClientResponse</code> 则是请求结束返回的响应就行了。这两个很好理解，再注意到注释里标明每一次链式调用的返回类型都是 <code>Future&lt;T&gt;</code> 。先知道这么多就够了，很明显，<code>Future</code> 在这里起着至关重要的作用，当然，在整个 Dart 的异步体系中，<code>Future</code> 也是主角之一。所以，让我们先来看看 <code>Future</code> 到底是什么。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><h3 id="Future-是什么"><a href="#Future-是什么" class="headerlink" title="Future 是什么"></a>Future 是什么</h3><p>从 API 文档的解释来说，<code>Future</code> 是一个代表延迟计算的对象，或者说，<code>Future</code> 包裹着在未来某一时刻可用的值或错误。</p>
<p>先看 <code>Future</code> 的一个构造器：<code>Future(FutureOr&lt;T&gt; computation())</code> 。<code>FutureOr&lt;T&gt; computation()</code> 就是一个函数，<code>Future</code> 包裹的，就是这个函数的执行结果，如果 <code>computation</code> 没有返回值，那这个 <code>Future</code> 就是 <code>Future&lt;void&gt;</code>；<code>computation</code> 有返回值 <code>T</code>，那这个 <code>Future</code> 就是 <code>Future&lt;T&gt;</code>；如果 <code>computation</code> 在执行过程抛出异常了，那这个 <code>Future</code> 就包裹了一个错误。除此之外，最重要的一点是，这些结果都是延迟的，是在未来某一时刻才可用的。下面以一个更通俗的例子来解释 <code>Future</code>。</p>
<p>比如小明为他女朋友准备了一个礼物，并且做了精美的包装，从外表看不出来里面装的是什么礼物，这时可以把这个包装盒看成是一个 <code>Future</code>，他女朋友撒娇要小明给她拆礼物，在小明拆开之前，那她拥有的就是一个盒子，而不是真正的礼物，当小明把包装盒拆开，他女朋友就得到了一个礼物，但是如果小明往盒子里装错了，放了一封别人写给他的情书，那这时候就引发了一个 <code>Error</code>。</p>
<p>由此，可以引出 <code>Future</code> 的 3 种状态：</p>
<ul>
<li><strong>Uncompleted</strong>：计算未完成。即盒子未打开时，小明的女朋友拥有的是一个礼物盒而不是一份礼物</li>
<li><strong>Completed with a value</strong>：计算完成并返回一个期望值。即打开的盒子里装着小明准备的礼物，他女朋友得到了一份礼物</li>
<li><strong>Completed with an error</strong>：计算完成并返回一个错误。即打开的盒子里装的不是礼物而是别人写给小明的情书，他女朋友得到了一份愤怒</li>
</ul>
<h3 id="Future-的使用"><a href="#Future-的使用" class="headerlink" title="Future 的使用"></a>Future 的使用</h3><p>现在我们已经知道了 <code>Future</code> 以及它的 3 种状态了，那么这三种状态如何体现到代码里呢。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Gift&gt; giftBox = Future(()&#123;</span><br><span class="line">  <span class="comment">// 准备礼物的过程，如果准备的过程出错了，则抛出一个异常 PrepareException</span></span><br><span class="line">  Gift gift = prepareGift();</span><br><span class="line">  <span class="keyword">return</span> gift;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果在拿到礼物之后出现了小问题，则抛出一个异常 GiftException</span></span><br><span class="line">giftBox.then((gift) =&gt; handleGift(gift))</span><br><span class="line">  .catchError((e) =&gt; handlePrepareException(), test: (e) =&gt; e <span class="keyword">is</span> PrepareException)</span><br><span class="line">  .catchError((e) =&gt; handleGiftException(), test: (e) =&gt; e <span class="keyword">is</span> GiftException)</span><br><span class="line">  .whenComplete(() =&gt; replay());</span><br></pre></td></tr></table></figure>

<p>可以看到，通过 <code>Future.then()</code> 函数可以拿到 <code>Future</code> 中计算完成的值，在 <code>then</code> 中可以对礼物进行处理，拍照发朋友圈或者十动然鱼都是 ok 的，处理结束后，返回值又被包装成一个 <code>Future</code> 作为 <code>then()</code> 的返回值。如果在准备礼物的过程中出错了，可以通过 <code>catchError</code> 进行兜底，当然任何一个步骤出现了错误都会直接转到兜底环节，就好像在拆开礼物之前小明发现自己准备的礼物在一个角落里，这时他可以直接进行兜底操作而不再去打开礼物盒，即不会执行 <code>then()</code> 里的方法。如果拿到礼物后女朋友并不是很满意，那小明可能还需要做一些补救措施，即通过第二个 <code>catchError</code> 进行兜底。可以看到，可以有多个 <code>catcheError</code> 针对不同类型的异常进行捕获处理，一旦发生异常，则直接跳到 <code>catcheError</code> 进行异常处理操作。当然了，完成了送礼物及后续一系列的操作后，小明应该有一个复盘总结的环节了，这时 <code>whenComplete()</code> 就发生作用了，不管中途有没有发生异常，都会有这样一个复盘总结的操作。</p>
<p>看到这里，应该有一种 <code>try-catch</code> 的熟悉感了，<code>then()</code> 就好比 <code>try</code> 这个操作，而 <code>catcheError</code> 就像是 <code>catch</code>，<code>whenComplete()</code> 就像是 <code>finally</code>。当然了，既然 <code>then()</code> 的返回值也是一个 <code>Future</code>，那就可以不停的往后面链接更多操作了，这样可以避免嵌套地狱的出现，也能比较清晰的看到代码执行的先后顺序。这时再回过头去看网络请求的例子就很好理解了。既然 <code>Future</code> 的 API 跟 <code>try-catch</code> 模式类似，也可以通过 <code>try-catch</code> 来实现同样的逻辑：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; openGift() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Gift gift = <span class="keyword">await</span> giftbox;</span><br><span class="line">    handleGift(gift);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    replay();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍有不同的是，在 <code>try-catch</code> 中出现了两个关键字：<code>async</code>、<code>await</code>，这两个关键字也是 <code>Dart</code> 异步的一部分，可以将异步代码写成同步的样子。</p>
<p><code>await</code> 用来获取 <code>Future</code> 的结果，因为 <code>Future</code> 的是异步的，而且不知道在哪个时刻会结束，所以顾名思义，就是需要等它结束之后再去执行后面的代码。需要注意的是，如果 <code>await</code> 的 <code>Future</code> 一直不结束，那么后面的代码则不会执行。</p>
<p><code>async</code> 会将它标注的函数返回值包装成一个 <code>Future</code>，当执行 <code>async</code> 标注的函数时，在遇到 <code>await</code> 之前，会将该函数当成同步函数执行，如果 <strong>遇到 <code>await</code>，则将 <code>await</code> 及后面的代码包装到一个 <code>Future</code> 中并结束当前函数，当 <code>await</code> 拿到对应的值再执行 <code>await</code> 后面的代码</strong>。</p>
<p>在理解了 <code>await</code> 和 <code>async</code> 之后，就可以把异步代码当成同步来写了，但是由于 <code>await</code> 有等不到结果的可能，因此需要谨慎。</p>
<p>以上就是 <code>Future</code> 相关的一些基础知识了，接下来看看 <code>Dart</code> 异步的另一个重要 API – <code>Stream</code>。</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p><code>Stream</code> 提供一个数据的异步序列，或者说一个异步的 <code>Iterable</code>，甚至可以理解为一个观察者模式。当注册了监听后，只要有新的数据就会执行回调，比如说点击事件、大段数据的一系列数据块或者从文件读取的字节流。再比如，小明每个节日都为他女朋友准备礼物，这样到了某个节日，小明就把礼物交给他女朋友，这样一个一个礼物的送就相当于 <code>Stream</code> 的一次次数据发送。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Gift&gt; gifts = ...;</span><br><span class="line">StreamSubscription giftSubscription = gifts.listen(</span><br><span class="line">  (gift) &#123; <span class="comment">// 收到礼物 &#125;,</span></span><br><span class="line">  onError: (e) &#123; <span class="comment">//某个礼物送错了 &#125;,</span></span><br><span class="line">  cancelOnError: <span class="keyword">false</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>就像以上代码，通过 <code>Stream.listen()</code> 方法监听数据。女朋友接收礼物就相当于生成了一个订阅 <code>StreamSubscription</code>，通过这个 <code>StreamSubscription</code> 可以控制暂停接收(<code>pause()</code>)、恢复接收(<code>resume()</code>)或者取消接收(<code>cancel()</code>)礼物。同样的，除了使用 <code>Stream</code> 的 API 接收数据外，也可以写成同步的形式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> receiveGift(Stream&lt;Gift&gt; gifts) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (Gift gift <span class="keyword">in</span> gifts) &#123;</span><br><span class="line">    <span class="comment">// 收到礼物</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于 <code>Future</code> 不同的是，<code>Stream</code> 使用 <code>await for</code> 等待数据的到来，这也体现了 <code>Stream</code> 可以理解为一个异步 <code>Iterable</code>，当 <code>Stream</code> 数据发送完毕时，循环才会结束，才会执行循环下面的代码，因此也需要注意死循环的问题。</p>
<h3 id="Stream-的创建"><a href="#Stream-的创建" class="headerlink" title="Stream 的创建"></a>Stream 的创建</h3><p>以上了解到了 <code>Stream</code> 的简单使用，那作为小明，该如何准备这个 GiftStream 呢？有以下两种方式：</p>
<ol>
<li><p>通过 <code>StreamController</code> 创建</p>
 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StreamController&lt;Gift&gt; giftController = StreamController();</span><br><span class="line">Stream&lt;Gift&gt; giftStream = controller.stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间到了，送出去一个礼物</span></span><br><span class="line">giftController.add(Gift());</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>async*</code>、 <code>yield</code>、<code>yield*</code> 关键字创建</p>
 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generateGift() <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="comment">// 时间到了，送出去一个礼物</span></span><br><span class="line">  <span class="keyword">yield</span> Gift();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generateGift() <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="comment">// 时间到了，堆积了几个礼物一次性送出去</span></span><br><span class="line">  <span class="keyword">yield</span>* giftStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>yield</code> 和 <code>yield*</code> 的区别就是，<code>yield</code> 发送单个数据，而 <code>yield*</code> 发送多个数据。</p>
</li>
</ol>
<h3 id="Stream-的种类"><a href="#Stream-的种类" class="headerlink" title="Stream 的种类"></a>Stream 的种类</h3><p><code>Stream</code> 有两种类型，一种是单一订阅型，另一种是广播型的。顾名思义，单一订阅型的表示这个 <code>Stream</code> 只能被监听一次，即只能调用一次 <code>listen()</code> 方法生成一个 <code>StreamSubscription</code>，比如从文件读取字节流。而广播型的则是可以被多次监听，可以产多多个 <code>StreamSubscription</code>。</p>
<p>以上便是 <code>Stream</code> 的入门知识。了解完 <code>Dart</code> 异步 API 的基础知识后，我们再来看看 <code>Dart</code> 异步机制背后的逻辑。</p>
<h2 id="异步机制"><a href="#异步机制" class="headerlink" title="异步机制"></a>异步机制</h2><p><code>Dart</code> 是单线程语言，这句话大家可能见到过很多次，也可能第一次见到，如果之前没有过类似异步机制语言的经验，小朋友的脑子里可能会充满了问号。单线程如何异步？单线程如何利用现代 CPU 的多核能力？这一部分，就来解决这些问题。</p>
<h3 id="异步概览"><a href="#异步概览" class="headerlink" title="异步概览"></a>异步概览</h3><p>首先认识两个概念：</p>
<ul>
<li><strong>阻塞式调用</strong>：调用后等待结果，当前线程被挂起，得到结果之前不会继续执行。就好比定了个外卖，在外卖送到之前不做任何事了，就死死的等着外卖小哥的电话</li>
<li><strong>非阻塞式调用</strong>：调用后不用等待结果，当前线程继续执行其他任务，等该调用执行完毕再处理结果。就好比定完外卖继续努力工作，外卖小哥电话到了再去拿外卖</li>
</ul>
<p>现在应该不难理解为什么单线程能实现异步操作了，基于非阻塞式调用就行呗，在等待耗时操作结果的时候继续执行其他任务，当耗时操作结束了再处理它的结果。那么现在问题来了，怎么样才知道耗时操作结束了呢？你不知道，也不需要知道，这些结果都会添加到一个队列中，单线程不停的去队列中取出事件进行处理。这个机制就是 <strong>事件循环机制</strong>，也就是 <strong>Event Loop</strong>。 Event loop 就是单线程实现异步的关键。</p>
<p><img src="http://img.crazypudding.com/dart-async-mechanism/event-loop.png" alt="event-loop"></p>
<p>如上图所示，每当有事件发生，比如点击了一个区域、设置了一个 <code>Timer</code>，这个事件就被添加到 Event queue 中，这个 Event queue 就是专门维护所有事件的一个队列，而 Event loop 则不停的从 Event queue 中获取事件并处理这个事件，直到 Event queue 中没有事件。</p>
<p>那么这种机制在 <code>Dart</code> 中是如何运作的呢？在 <code>Dart</code> 中，有一个 <code>Isolate</code> 的概念，<code>Isolate</code> 是 <code>Dart</code> 代码的运行环境，每个 <code>Isolate</code> 在同一时刻只能有一个工作线程与其绑定，可以先简单理解为一个 <code>Isolate</code> 就是一个线程。</p>
<p><code>Dart</code> 程序的 <code>main()</code> 函数所在的 <code>Isolate</code> 称为 <code>mainIsolate</code>，可以在 <code>Isolate</code> 中开辟出一个新的 <code>Isolate</code>，但是各个 <code>Isolate</code> 之间代码是孤立的，彼此不共享内存，所以也可以理解为，一个 <code>Isolate</code> 就是一个隔离的内存块，其他 <code>Isolate</code> 不能访问当前 <code>Isolate</code> 的内存。</p>
<p>在每个 <code>Isolate</code> 中都有一套 Event loop 机制。每当 <code>Isolate</code> 启动的时候，先执行它的入口函数 – 在 <code>mainIsolate</code> 中即为 <code>main()</code>，当入口函数执行完毕则开始从 Event queue 中一个一个地拿取事件进行处理。所以 <code>Dart</code> 程序的运行顺序显而易见，先执行 <code>main()</code> 函数，再执行 Event queue 中的事件。</p>
<p>在理解了上面的主流程之后，再稍微往细一点看，<code>Dart</code> 的 Event loop 机制其实维护了两个队列，一个是 <strong>microtask queue</strong>，一个是 <strong>event queue</strong>。</p>
<ul>
<li><em>event queue：*</em>event queue 中包含所有的外部事件，比如 I/O、绘制事件、点击事件、Timer、Isolate 间的消息处理等</li>
<li><em>microtask queue：*</em>在 Event loop 开始自动的从 event queue 拿取事件之前做一些额外的操作。</li>
</ul>
<p>event queue 中的事件可以来自 <code>Dart</code> 代码和系统的其他部分(C 层)，而 microtask queue 只能从 <code>Dart</code> 代码中添加事件。</p>
<p><img src="http://img.crazypudding.com/dart-async-mechanism/dart-event-queues-order.png" alt="dart-event-queues-order"></p>
<p>这是，<code>Dart</code> 程序的运行顺序可以整理成上图的模式。当 <code>Dart</code> 程序或者说 <code>Isolate</code> 启动时，先执行入口函数，期间会有各种各样的事件或者任务加入到对应的 queue 中，当入口函数执行完毕时，Event loop 开始工作，先从 microtask queue 中拿取事件进行处理，当 microtask queue 中的任务处理完了，即 microtask queue 空了，这时开始从 event queue 中拿取第一个事件进行处理，处理完第一个 event 之后再检查一遍 microtask queue，如此往复，这就是 Event loop 的工作过程：先执行 microtask 中所有任务，再执行 event queue 中第一个事件，之后再重复这两个步骤，直到 event queue 为空了，这时意味着程序的任务完成了，处于可以随时退出的状态。</p>
<p>需要注意的是，当执行 microtask queue 中的任务时，event queue 时处于挂起状态的，在处理这两个队列的任务或者事件时，也可以往其中插入新的任务或事件。鉴于 microtask queue 会阻塞 event queue，所以不要再 microtask queue 中执行耗时任务，这会阻塞 event queue 导致绘制、渲染事件被暂停，造成卡顿。</p>
<p>OK，现在对于 Event loop 运行的过程有个整体的了解，那么我们如何把任务添加到这两个队列中呢？可以通过以下特性将任务添加到对应的队列：</p>
<ol>
<li><code>Future</code>、<code>Timer</code> 中的代码将作为一个事件添加到 event queue 的队尾</li>
<li><code>Stream</code>、<code>scheduleMicrotask()</code> 中的代码将作为一个任务添加到 microtask queue 的队尾</li>
</ol>
<p>通过以上的内容，结合 <code>Future</code> 可以通过 <code>then()</code> 来控制每个 <code>Future</code> 的执行顺序，我们便可以自由的控制每一行代码的执行顺序了。</p>
<h3 id="Isolate-的使用"><a href="#Isolate-的使用" class="headerlink" title="Isolate 的使用"></a>Isolate 的使用</h3><p>现在我们已经解决了 <code>Dart</code> 单线程异步的实现问题，也知道了，在 <code>Dart</code> 中，<code>Isolate</code> 就是这个单线程模型的运行环境。那么就还剩下一个问题，<code>Dart</code> 如何利用 CPU 的多核能力了。很显然，就是开辟不同的 <code>Isolate</code> 去处理那些耗时任务嘛。但是前面也提到了，<code>Isolate</code> 之间是不共享内存的，那耗时任务处理完了把结果通知给 <code>mainIsolate</code> 就需要一套通信机制来实现了，<code>Dart</code> 采用的是 <code>Port</code> 的机制，通过 <code>ReceivePort</code> 和 <code>SendPort</code> 实现 <code>Isolate</code> 间的通信。</p>
<p>每个 <code>Isolate</code> 都可以创建出 <code>ReceivePort</code>，从 <code>ReceivePort</code> 可以通过 getter 方法 – <code>sendPort</code> 来获取对应这个 <code>ReceivePort</code> 的 <code>SendPort</code>。<code>ReceivePort</code> 和 <code>SendPort</code> 是一套东西，就相当于连接两个 <code>Isolate</code> 的管道，<code>ReceivePort</code> 是当前 <code>Isolate</code> 用来接收消息的一端，对应的 <code>SendPort</code> 是管道的另一端，通过 <code>SendPort</code> 发送的消息可以在另一端的 <code>ReceivePort</code> 接收到。如下图，一个 <code>ReceivePort</code> 可以有多个 <code>SendPort</code>，在开辟 <code>Isolate</code> 的时候，当前 <code>Isolate</code> 将自己 <code>ReceivePort</code> 对应的一个 <code>SendPort</code> 交给新开辟出来的 <code>Isolate</code> 就相当于把自己通信管道的发送端给了新的 <code>Isolate</code>，这样就可以愉快的接收新 <code>Isolate</code> 发送过来的消息了。</p>
<p><img src="http://img.crazypudding.com/dart-async-mechanism/isolate-communicate.png" alt="isolate-communicate"></p>
<p>来看看具体代码实现吧：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  ReceivePort receivePort = ReceivePort();</span><br><span class="line">  <span class="comment">// 通过 Isolate.spawn() 开辟一个新的 Isolate</span></span><br><span class="line">  <span class="comment">// 第一个参数是带有单个参数的顶级函数或者静态函数，这个函数就是新 Isolate 的入口函数</span></span><br><span class="line">  <span class="comment">// 第二个参数是新 Isolate 入口函数的参数值，由于想要实现消息回传，因此传入 mainIsolate 的一个 sendPort</span></span><br><span class="line">  Isolate.spawn(entryPoint, receivePort.sendPort);</span><br><span class="line">  receivePort.listen((message) &#123;</span><br><span class="line">    <span class="comment">// 可以处理新 Isolate 发送过来的消息</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> entryPoint(<span class="built_in">dynamic</span> message) &#123;</span><br><span class="line">  <span class="comment">// 新开辟的 Isolate 会接收到入口函数带过来的一条消息</span></span><br><span class="line">  SendPort sendPort = message;</span><br><span class="line">  sendPort.send(messageFromNewIsolate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上便是 <code>Isolate</code> 的基础知识了，了解完这些，想在 <code>Dart</code> 程序利用多线程就很简单了，根据需要开辟新的 <code>Isolate</code> 就行了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，便完成了文章开头提到的几个问题，简单了解了 <code>Dart</code> API 的一些基础知识，也从全局对 <code>Dart</code> 的异步机制有了一定的了解，如此，不管是更好的实现异步编程还是更深入的研究 <code>Dart</code> 异步的实现原理，都能有一个相对明确的道路了。</p>
<p>希望对你有所帮助，欢迎一起交流～</p>
<h2 id="Thanks-To"><a href="#Thanks-To" class="headerlink" title="Thanks To"></a>Thanks To</h2><ul>
<li>《Dart cookbook》– 第 8 章 Working with Futures, Tasks, and Isolates</li>
<li>《Flutter in action》– 第 9 章 Async Dart and Flutter infinite scrolling</li>
<li><a href="https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137" target="_blank" rel="noopener">Dart asynchronous programming: Futures</a></li>
<li><a href="https://youtu.be/nQBpOIHE4eE" target="_blank" rel="noopener">Dart asynchronous programming: Streams</a></li>
<li><a href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a" target="_blank" rel="noopener">Dart asynchronous programming: Isolates and event loops</a></li>
<li><a href="https://web.archive.org/web/20170704074724/https://webdev.dartlang.org/articles/performance/event-loop" target="_blank" rel="noopener">The Event loop and Dart</a></li>
<li><a href="https://dart.dev/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">Dart language tour: Async support</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Learning-Notes/" rel="tag"># Learning Notes</a>
              <a href="/tags/Flutter/" rel="tag"># Flutter</a>
              <a href="/tags/Dart/" rel="tag"># Dart</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/29/how-flutter-rendering/" rel="prev" title="浅析 Flutter 渲染原理">
      <i class="fa fa-chevron-left"></i> 浅析 Flutter 渲染原理
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">赣ICP备16009806号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Crazypudding</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">84k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:17</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"d6IWzX7FjgQks0Y7UioDD24l-gzGzoHsz","app_key":"GMrkaVwqnkjwRbJGmzs42wHK","security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://crazypudding.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://www.crazypudding.com/2020/09/02/dart-async-mechanism/";
    this.page.identifier = "2020/09/02/dart-async-mechanism/";
    this.page.title = "浅析 Dart 异步机制";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://crazypudding.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
